o: ActiveSupport::Cache::Entry:@valueI"“// groupOrdered takes two channels, one for input and one for
// results, and passes tuples that belong to the same group
// to the appropriate output channel.  It also takes a
// predicate, which when evaluated on two input tuples returns
// a true if they belong to the same group, otherwise false.
// It also takes n, which is the buffer size that should be
// used for the inner result channels.
func groupOrdered(in <-chan tuple, res chan chan tuple, p predicate, n int) {
	go func() {
		
		// initialization is a bit trickier here.
		// We can't compare the first tuple to any
		// other tuples, but that's fine because
		// it means we can sent it immeidately.
		inner := make(chan tuple, n)
		prev, ok := <-in
		// On the other hand, in might have been 
		// closed and never sent any values, so we
		// have to check for that case.
		if ok {
			res <- inner
			inner <- prev
		} else {
			close(res)
			return
		}
		
		// read each input,
		for v := range in {
			// if it is has not already been
			// encountered, send it on the results
			// channel and then update the prev
			// variable.  If it has not been
			// encountered, then close the results
			// channel and create a new one
			if p(&v, &prev) {
				inner <- v
			} else {
				close(inner)
				inner = make(chan tuple, n)
				res <- inner
				inner <- v
				prev = v
			}
		}
		// close the resulting channels
		close(inner)
		close(res)
	}()
	return
}:ET:@created_atf1405462200.718393:@expires_in0