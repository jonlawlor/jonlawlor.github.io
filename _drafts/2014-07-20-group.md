---
layout: post
title: Group
---

Group is a non-relational primative that I will be using to construct relational operations.  The basic idea is to put similar tuples together in a channel, and to delimit when a new similar group is being sent by putting it into another channel.

As an example, if we use the tuple type from before:

{% highlight go %}
type tuple struct {
  foo int
  bar int
}
{% endhighlight %}

Then given an example channel which produces tuples:
{% highlight go %}
ch := make(chan<- tuple)
ch <- tuple{1, 1}
ch <- tuple{1, 2}
ch <- tuple{1, 3}
ch <- tuple{2, 1}
ch <- tuple{2, 2}
{% endhighlight %}

Then we want the `group` function to produce a channel that returns a channel that produces {1,1}, {1,2}, {1,3}, and then closes, and then produce the values {2,1}, {2,2} on another channel, and then closes that one.  Both of those channels will be returned in a channel, which can be thought of as a channel of groups.

The requirements for a group function are as follows:

* Takes input tuples from a channel with tuples that can be compared for equality.  Typically this will mean that some of the fields in a structure are equal, although it could also be values in a range, or values that are close to each other.
* Sends the result tuples on a channel of channels of tuples.  The inner channels each contain the similar group of tuples, and the outer channel represents the channel of all groups of tuples.

On the face of it, we have a big problem if we try to perform this on an unordered input.  When the input is unordered, the last input tuple could belong to the same group as the first input tuple, which means that we can't close the first group channel before the last input tuple has been examined.  With that in mind, we'll implement the ordered version first.

For a predicate, I typically use
{% highlight go %}
type predicate func(t1, t2 *tuple) bool

p := func(t1, t2 *tuple) bool { return t1.foo == t2.foo }

{% endhighlight %}

{% gist jonlawlor/9d2ef31380685339693a %}

This function is a bit hairier than [distinct]({% post_url 2014-07-18-distinct %}), but the {% highlight go %} chan<- (chan<- tuple) {% endhighlight %} is actually a great fit for the problem.  We also could have made the buffering adaptive, and had it determine the length of the buffer based on the number of tuples in previous groups.  Also, note that the output has the same ordering as the input.

Now to implement the unordered version.  It can't perform the same kind of arbitrary predicate evaluation as the ordered version.  We use a subdomain of the input tuple to determine which groups each tuple belongs to.  Also, basically all of the tuples will be in memory.  The results will be unordered, and it will still have to read all of the inputs.  However, it will be able to produce initial values quickly, which will be useful later.

For testing, I use something like this:
{% highlight go %}
// we can only perform grouping on equality when we're using a hash
type subTup struct{ foo int }

func proj(t *tuple) subTup { return subTup{t.foo} }
{% endhighlight %}

{% gist jonlawlor/bdd38e1448a261095706 %}



### Performance

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Upvotes</th>
      <th>Downvotes</th>
    </tr>
  </thead>
  <tfoot>
    <tr>
      <td>Totals</td>
      <td>21</td>
      <td>23</td>
    </tr>
  </tfoot>
  <tbody>
    <tr>
      <td>Alice</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <td>Bob</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>Charlie</td>
      <td>7</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
